# Task ID: 9
# Title: Build Content Diversity and Freshness System
# Status: pending
# Dependencies: 4
# Priority: medium
# Description: Develop mechanisms to ensure feed content is diverse and fresh, avoiding echo chambers and content staleness.
# Details:
Create a system that:
1. Analyzes content diversity across different dimensions (topics, sources, perspectives)
2. Injects fresh and diverse content into feeds
3. Balances familiarity with discovery
4. Prevents overexposure to similar content

Implementation should include:
```
class ContentDiversityService {
  async diversifyFeed(userId, candidateItems) {
    // Get user's recent feed history
    const recentFeedHistory = await this.feedHistoryRepository.getRecent(userId, 100);
    
    // Calculate diversity metrics for candidate items
    const diversityScores = await this.calculateDiversityScores(candidateItems, recentFeedHistory);
    
    // Apply diversity boosting to scores
    const diversifiedItems = candidateItems.map((item, index) => {
      const diversityBoost = this.calculateDiversityBoost(diversityScores[index]);
      return {
        ...item,
        score: item.score * diversityBoost
      };
    });
    
    // Ensure minimum representation of fresh content
    return this.ensureFreshContentQuota(diversifiedItems);
  }
  
  calculateDiversityBoost(diversityScore) {
    // Higher boost for more diverse content
    return 1 + (diversityScore * 0.2); // Up to 20% boost for diverse content
  }
}
```

# Test Strategy:
Unit tests for diversity calculations and scoring. Integration tests with sample user histories to verify diversity improvements. A/B testing to measure user engagement with more diverse feeds. User surveys to gather qualitative feedback on content variety.

# Subtasks:
## 1. Implement Content Diversity Analysis Service [pending]
### Dependencies: None
### Description: Create a service that analyzes content diversity across different dimensions including topics, sources, and perspectives. This service will calculate diversity scores for content items relative to a user's recent feed history.
### Details:
class ContentDiversityAnalyzer {
  constructor(contentRepository, taxonomyService) {
    this.contentRepository = contentRepository;
    this.taxonomyService = taxonomyService;
  }

  async calculateDiversityScores(candidateItems, recentFeedHistory) {
    const diversityScores = [];
    
    // Extract features from recent history
    const historicalFeatures = await this.extractContentFeatures(recentFeedHistory);
    const historicalTopics = this.aggregateTopics(historicalFeatures);
    const historicalSources = this.aggregateSources(historicalFeatures);
    const historicalPerspectives = this.aggregatePerspectives(historicalFeatures);
    
    // Calculate diversity score for each candidate item
    for (const item of candidateItems) {
      const itemFeatures = await this.extractContentFeatures([item]);
      
      // Calculate topic diversity (how different is this topic from recent history)
      const topicDiversity = this.calculateTopicDiversity(itemFeatures[0].topics, historicalTopics);
      
      // Calculate source diversity
      const sourceDiversity = this.calculateSourceDiversity(itemFeatures[0].source, historicalSources);
      
      // Calculate perspective diversity
      const perspectiveDiversity = this.calculatePerspectiveDiversity(itemFeatures[0].perspective, historicalPerspectives);
      
      // Combine into overall diversity score (weighted average)
      const overallDiversity = (topicDiversity * 0.4) + (sourceDiversity * 0.3) + (perspectiveDiversity * 0.3);
      
      diversityScores.push(overallDiversity);
    }
    
    return diversityScores;
  }
  
  async extractContentFeatures(contentItems) {
    // Extract topics, sources, and other features from content items
    // This might involve calling content analysis services or using pre-computed metadata
    return contentItems.map(item => ({
      id: item.id,
      topics: item.topics || [],
      source: item.source,
      perspective: item.perspective || 'neutral',
      timestamp: item.createdAt
    }));
  }
  
  // Helper methods for diversity calculations
  calculateTopicDiversity(itemTopics, historicalTopics) {
    // Calculate how different this item's topics are from historical distribution
    // Higher score = more diverse/different from what user has seen recently
    // Implementation could use Jaccard distance or other similarity metrics
  }
  
  // Similar methods for source and perspective diversity
}

## 2. Build Fresh Content Identification System [pending]
### Dependencies: None
### Description: Develop a system that identifies and prioritizes fresh content, ensuring new and timely items are properly represented in feeds. This system will track content age and popularity trends to determine freshness.
### Details:
class FreshnessService {
  constructor(contentRepository, trendingService) {
    this.contentRepository = contentRepository;
    this.trendingService = trendingService;
  }
  
  async calculateFreshnessScores(candidateItems) {
    const freshnessScores = [];
    const now = new Date();
    
    for (const item of candidateItems) {
      // Base freshness on recency (time decay function)
      const ageInHours = (now - new Date(item.createdAt)) / (1000 * 60 * 60);
      let freshnessScore = this.calculateRecencyScore(ageInHours);
      
      // Boost freshness for trending or timely content
      const trendingScore = await this.trendingService.getTrendingScore(item.id);
      freshnessScore = freshnessScore * (1 + (trendingScore * 0.5));
      
      // Consider content seasonality or time-relevance if applicable
      if (item.timeRelevant) {
        freshnessScore *= 1.2; // 20% boost for time-relevant content
      }
      
      freshnessScores.push(freshnessScore);
    }
    
    return freshnessScores;
  }
  
  calculateRecencyScore(ageInHours) {
    // Exponential decay function for recency
    // Very new content (< 1 hour) gets highest score
    // Score gradually decreases as content ages
    return Math.exp(-0.05 * ageInHours);
  }
  
  identifyStaleContent(userFeedHistory, timeThresholdHours = 72) {
    // Identify content types that have been overexposed in user's feed
    const now = new Date();
    const recentHistory = userFeedHistory.filter(item => {
      const ageInHours = (now - new Date(item.seenAt)) / (1000 * 60 * 60);
      return ageInHours <= timeThresholdHours;
    });
    
    // Group by content attributes to find overexposed categories
    // Return list of content types/sources that should be limited
  }
}

## 3. Implement Echo Chamber Prevention Algorithm [pending]
### Dependencies: 9.1
### Description: Create an algorithm that identifies and prevents echo chambers by ensuring users are exposed to a variety of perspectives and content sources, even when their engagement patterns might naturally lead to homogeneous content.
### Details:
class EchoChamberPreventionService {
  constructor(userProfileService, contentDiversityAnalyzer) {
    this.userProfileService = userProfileService;
    this.contentDiversityAnalyzer = contentDiversityAnalyzer;
  }
  
  async calculateEchoChamberRisk(userId, recentFeedHistory) {
    // Analyze user's recent engagement patterns
    const userEngagements = await this.userProfileService.getUserEngagements(userId, 100);
    
    // Calculate topic concentration (how concentrated in few topics)
    const topicConcentration = this.calculateTopicConcentration(userEngagements);
    
    // Calculate source concentration (how concentrated in few sources)
    const sourceConcentration = this.calculateSourceConcentration(userEngagements);
    
    // Calculate perspective bias (how skewed toward certain perspectives)
    const perspectiveBias = this.calculatePerspectiveBias(userEngagements);
    
    // Combined echo chamber risk score (higher = more at risk)
    return (topicConcentration * 0.4) + (sourceConcentration * 0.3) + (perspectiveBias * 0.3);
  }
  
  async applyEchoChamberPrevention(userId, candidateItems, recentFeedHistory) {
    // Calculate user's echo chamber risk
    const echoChamberRisk = await this.calculateEchoChamberRisk(userId, recentFeedHistory);
    
    if (echoChamberRisk > 0.7) { // High risk threshold
      // Get diversity scores for candidate items
      const diversityScores = await this.contentDiversityAnalyzer.calculateDiversityScores(
        candidateItems, recentFeedHistory
      );
      
      // Apply stronger diversity boosting for high-risk users
      return candidateItems.map((item, index) => {
        const diversityBoost = 1 + (diversityScores[index] * 0.4 * echoChamberRisk);
        return {
          ...item,
          score: item.score * diversityBoost
        };
      });
    }
    
    // For low-risk users, apply minimal or no adjustment
    return candidateItems;
  }
  
  // Helper methods for concentration calculations
  calculateTopicConcentration(engagements) {
    // Calculate how concentrated user engagement is across topics
    // Higher value = more concentrated in fewer topics = higher echo chamber risk
  }
  
  // Similar methods for source and perspective concentration
}

## 4. Develop Content Quota and Balancing System [pending]
### Dependencies: 9.2
### Description: Create a system that ensures proper balance between familiar and discovery content by implementing quotas for different content types, sources, and freshness levels in user feeds.
### Details:
class ContentBalancingService {
  constructor(userPreferenceService) {
    this.userPreferenceService = userPreferenceService;
  }
  
  async applyContentQuotas(userId, rankedItems) {
    // Get user preferences for content balance
    const userPreferences = await this.userPreferenceService.getPreferences(userId);
    
    // Default quotas if user has no specific preferences
    const quotas = userPreferences.contentQuotas || {
      fresh: 0.3, // 30% fresh content
      familiar: 0.5, // 50% familiar/preferred content
      discovery: 0.2 // 20% discovery content
    };
    
    // Categorize items
    const categorizedItems = this.categorizeItems(rankedItems, userId);
    
    // Calculate how many items of each type to include
    const totalItems = rankedItems.length;
    const freshQuota = Math.ceil(totalItems * quotas.fresh);
    const familiarQuota = Math.ceil(totalItems * quotas.familiar);
    const discoveryQuota = Math.ceil(totalItems * quotas.discovery);
    
    // Build balanced feed
    const balancedFeed = [
      ...this.selectTopItems(categorizedItems.fresh, freshQuota),
      ...this.selectTopItems(categorizedItems.familiar, familiarQuota),
      ...this.selectTopItems(categorizedItems.discovery, discoveryQuota)
    ];
    
    // Re-rank the balanced feed items based on their original scores
    return balancedFeed.sort((a, b) => b.score - a.score);
  }
  
  categorizeItems(items, userId) {
    // Categorize items as fresh, familiar, or discovery based on content attributes
    // This is a simplified implementation - real version would use more sophisticated logic
    return {
      fresh: items.filter(item => item.freshness > 0.7),
      familiar: items.filter(item => item.userRelevance > 0.7),
      discovery: items.filter(item => item.discoveryScore > 0.7)
    };
  }
  
  selectTopItems(items, count) {
    // Select the top N items from a category based on score
    return items.sort((a, b) => b.score - a.score).slice(0, count);
  }
  
  ensureMinimumSourceDiversity(feed, minSources = 3) {
    // Ensure feed has content from at least N different sources
    const sources = new Set(feed.map(item => item.source));
    
    if (sources.size < minSources) {
      // Implementation to replace some items to increase source diversity
    }
    
    return feed;
  }
}

## 5. Integrate Diversity and Freshness System with Feed Generation [pending]
### Dependencies: 9.1, 9.2, 9.3, 9.4
### Description: Integrate all components of the diversity and freshness system with the main feed generation algorithm, ensuring proper scoring, ranking, and presentation of diverse content in user feeds.
### Details:
class ContentDiversityService {
  constructor(
    contentDiversityAnalyzer,
    freshnessService,
    echoChamberPreventionService,
    contentBalancingService,
    feedHistoryRepository
  ) {
    this.contentDiversityAnalyzer = contentDiversityAnalyzer;
    this.freshnessService = freshnessService;
    this.echoChamberPreventionService = echoChamberPreventionService;
    this.contentBalancingService = contentBalancingService;
    this.feedHistoryRepository = feedHistoryRepository;
  }
  
  async diversifyFeed(userId, candidateItems) {
    // Get user's recent feed history
    const recentFeedHistory = await this.feedHistoryRepository.getRecent(userId, 100);
    
    // Step 1: Calculate diversity scores for candidate items
    const diversityScores = await this.contentDiversityAnalyzer.calculateDiversityScores(
      candidateItems, recentFeedHistory
    );
    
    // Step 2: Calculate freshness scores
    const freshnessScores = await this.freshnessService.calculateFreshnessScores(candidateItems);
    
    // Step 3: Apply diversity and freshness boosting to scores
    let diversifiedItems = candidateItems.map((item, index) => {
      const diversityBoost = this.calculateDiversityBoost(diversityScores[index]);
      const freshnessBoost = this.calculateFreshnessBoost(freshnessScores[index]);
      
      return {
        ...item,
        diversityScore: diversityScores[index],
        freshnessScore: freshnessScores[index],
        score: item.score * diversityBoost * freshnessBoost
      };
    });
    
    // Step 4: Apply echo chamber prevention for at-risk users
    diversifiedItems = await this.echoChamberPreventionService.applyEchoChamberPrevention(
      userId, diversifiedItems, recentFeedHistory
    );
    
    // Step 5: Apply content quotas and balancing
    const balancedFeed = await this.contentBalancingService.applyContentQuotas(
      userId, diversifiedItems
    );
    
    // Step 6: Final ranking and return
    return balancedFeed.sort((a, b) => b.score - a.score);
  }
  
  calculateDiversityBoost(diversityScore) {
    // Higher boost for more diverse content
    return 1 + (diversityScore * 0.2); // Up to 20% boost for diverse content
  }
  
  calculateFreshnessBoost(freshnessScore) {
    // Higher boost for fresher content
    return 1 + (freshnessScore * 0.3); // Up to 30% boost for fresh content
  }
  
  // Method to log diversity metrics for monitoring and improvement
  async logDiversityMetrics(userId, finalFeed) {
    // Calculate and log diversity metrics for the final feed
    // This data can be used for monitoring and improving the system
  }
}

